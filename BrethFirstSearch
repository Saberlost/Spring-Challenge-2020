/**
 * Grab the pellets as fast as you can!
 **/




class Cell {
    constructor (
        private pebble :number,
        private wall : Boolean,
        private x : number, 
        private y : number,
        private discovered : Boolean = false,
        private pacmanId : number = -1
       
        ) {}
        

 
    isWall()  : Boolean  {
        return this.wall;
    }
    
    getPebbleScore() : number {
        return this.pebble
    }
    setPebbleScore(pebbleScore:number){
        this.pebble = pebbleScore
    }

    getX() :number{
        return this.x;
    }
    
    getY() : number {
        return this.y;
    }


    //Used when searching?
    isDiscovered() : Boolean {
        return this.discovered;
    }
    
    setDiscovered(discovered: Boolean){
        this.discovered = discovered
    }

    isPacman() :Boolean{
        return this.pacmanId != -1
    }
    
    setPacmanId(pacmanId : number){
        this.pacmanId = pacmanId
    }

    getPacmanId() :number {
        return this.pacmanId
    }

 
    
}


enum PacmanType {
    Rock = "ROCK",
    Paper = "PAPER",
    Scissors = "SCISSORS",
    None = ""
}


class Pacman{
     constructor (
        private id:number,
        private cell: Cell,
        private oldCell : Cell = null,
        private type : PacmanType = PacmanType.None,
        private exploreX : number = -1,
        private exploreY : number = -1,
        private failedMove : number = 0,
        private speedCooldown : number = 0,
        private speedTurnsLeft : number = 0
        ) {}

    getId() : number{
        return this.id
    }

    getType():PacmanType{
        return this.type
    }
    setType(type :PacmanType){
        this.type = type
    }

    getCell():Cell{
        return this.cell
    }



    setCell(cell :Cell ){
        this.oldCell = this.cell
        this.cell = cell;
        if(this.oldCell == cell){
            //did not move
            this.failedMove += 1
        } else{
            this.failedMove = 0
        }
    }

    setSpeedColdown(cooldown : number){
        this.speedCooldown = cooldown

    }

    isSpeedOnColdown() :Boolean {
        return this.speedCooldown> 0
    }

    getSpeedTurnsLeft() :number{
        return this.speedTurnsLeft
    }
    
    setSpeedTurnsLeft(left : number){
        this.speedTurnsLeft = left
    }

    needNewStrategy() :Boolean{
        if(this.failedMove > 3){
            return true
        }
        return false
    }

    getExploreX() : number{
        return this.exploreX;
    }
    setExploreX(x : number){
        return this.exploreX = x;
    }

    getExploreY() : number{
        return this.exploreY;
    }
    
    setExploreY(y : number){
        return this.exploreY = y;
    }

    standOnExplore() :boolean{
        return 
            (this.cell.getX() == this.exploreX &&
            this.cell.getY() == this.exploreY ) ||
            this.exploreX == -1
    }


}




let board : Array<Cell> = new Array<Cell>()

var inputs: string[] = readline().split(' ');
const width: number = parseInt(inputs[0]); // size of the grid
const height: number = parseInt(inputs[1]); // top left corner is (x=0, y=0)
for (let i = 0; i < height; i++) {
    const row: string = readline(); // one line of the grid: space " " is floor, pound "#" is wall
    console.error("row : " +row)

    for (let j = 0; j < width; j++){
        if(row.charAt(j) == '#'){
            board.push(new Cell(0, true,  j, i));
        } else  {
             board.push(new Cell(0, false,  j ,i ));
        }
    }
}



function toBoardNumber(x :number, y:number ) : number{
    //console.error("x"+x +" y " +y +" gives :" + (y*width +x ))
    return y*width +x ;
}



function getRandomInt(max: number) :number {
  return Math.floor(Math.random() * Math.floor(max));
}


function up (y : number ) : number {
    return y-1;
}


function down (y : number ) : number {
    return y+1;
}

function left (x : number ) : number {
    return x-1;
}


function right (x : number ) : number {
    return x+1;
}



function getUpCell(x: number, y: number, board : Array<Cell>) : Cell{
    let newy = up(y)
    if (newy < 0){
        return null;
    }
    return board[toBoardNumber(x,newy)] 
}


function getDownCell(x: number, y: number, board : Array<Cell>) : Cell{
    let newy = y +1;
    if (newy > height){
        return null;
    }
    
    return board[toBoardNumber(x,newy)] 
   
}

function getLeftCell(x: number, y: number, board : Array<Cell>) : Cell{
    let newX =  x -1;
    if (newX < 0){
        return null;
    }
    return board[toBoardNumber(newX,y)] 
}

function getRigthCell(x: number, y: number, board : Array<Cell>) : Cell{
    let newX =  x + 1;
    if (newX > width){
        return null;
    }
   return board[toBoardNumber(newX,y)] 
   
}

function checkAndEnqueu(cell : Cell, prevCell:Cell, nextCells:Array<Cell>, myPacman : Map<number, Pacman>) : Boolean{
    if (cell != null && cell.isDiscovered() == false &&  !cell.isWall() && myPacman.has(cell.getPacmanId())) {// && !cell.isPacman()){
        cell.setDiscovered(true);
        nextCells.push(cell)
        return true;
    }
    return false;
}



//Breth first search for the cloest pebble
function findPath(x : number, y : number ,  board : Array<Cell>, pacman:Pacman, myPacman : Map<number, Pacman>, evilPacman : Map<number, Pacman>) :Cell{
    let nextCells : Array<Cell> = new Array<Cell>();
    let allVisitedCelsls :Array<Cell> = new Array<Cell>();
    let c: Cell = board[toBoardNumber(x,y)]    
    c.setDiscovered(true);
    nextCells.push(c);
    let depth : number = 0;
    let checkExtraDepth :number = 0
    
    if (pacman.getSpeedTurnsLeft() > 0){
        checkExtraDepth = 1
    }
    while (nextCells.length > 0){
        let v : Cell = nextCells.shift()// pop == depth first? shift = breth first?

        if (evilPacman.has(v.getPacmanId())){
            let evil : Pacman = evilPacman.get(v.getPacmanId())
            if(pacman.getType() == PacmanType.Paper && evil.getType() == PacmanType.Rock)
            {
                return v
            }
            else if(pacman.getType() == PacmanType.Rock && evil.getType() == PacmanType.Scissors)
            {
                return v
            }
            else if(pacman.getType() == PacmanType.Scissors && evil.getType() == PacmanType.Paper)
            {
                return v
            }
            else {
                continue
            }


        }


        if(v.getPebbleScore() > 0){ //WE are only finding the clost now
             if (checkExtraDepth > 0){
                let up :Cell = getUpCell(v.getX(), v.getY(), board)
                let down :Cell = getDownCell(v.getX(), v.getY(), board)
                let left :Cell = getLeftCell(v.getX(), v.getY(), board)
                let rigth :Cell = getRigthCell(v.getX(), v.getY(), board)
                if (up != null && up.getPebbleScore() > 0){
                    return up
                }
                if (down != null && down.getPebbleScore() > 0){
                    return down
                }
                if (left != null && left.getPebbleScore() > 0){
                    return left
                }
                if (rigth != null && rigth.getPebbleScore() > 0){
                    return rigth
                }
                return v

            } else {
                return v
            }            
        }

        
        allVisitedCelsls.push(v)
        let up :Cell = getUpCell(v.getX(), v.getY(), board, myPacmans)
        let down :Cell = getDownCell(v.getX(), v.getY(), board, myPacmans)
        let left :Cell = getLeftCell(v.getX(), v.getY(), board, myPacmans)
        let rigth :Cell = getRigthCell(v.getX(), v.getY(), board, myPacmans)
        

        checkAndEnqueu(left, v, nextCells);
        checkAndEnqueu(up,  v, nextCells);
        checkAndEnqueu(down, v, nextCells);
        checkAndEnqueu(rigth, v, nextCells);
       
        depth++
    }
    console.error("Searched to depth : " + depth)
    
    console.error("allVisitedCelsls lenght : " + allVisitedCelsls.length)
    if (depth == 1){
        return null
    }
    
    return null
/*
    let finalCell: Cell = allVisitedCelsls.pop();
    
   
 
    return finalCell;
    */
}


function setOtherPacmanRoute(pacman, board){
    if (!pacman.standOnExplore()){
        var cell:Cell = board[toBoardNumber(getRandomInt(width) , getRandomInt(height))];
        while(cell.isWall()){
            cell = board[toBoardNumber(getRandomInt(width) , getRandomInt(height))];
        }
        pacman.setExploreX(cell.getX())
        pacman.setExploreY(cell.getY())
    }
}






 let myPacmans : Map<number, Pacman> = new Map<number, Pacman>()
 

// game loop
while (true) {

    let evilPacmans : Map<number, Pacman> = new Map<number, Pacman>()
   
    board.forEach(function(c :Cell) {
         c.setDiscovered(false)
         c.setPebbleScore(0)
         c.setPacmanId(-1)
    })
    var inputs: string[] = readline().split(' ');
    const myScore: number = parseInt(inputs[0]);
    const opponentScore: number = parseInt(inputs[1]);
    const visiblePacCount: number = parseInt(readline()); // all your pacs and enemy pacs in sight
    for (let i = 0; i < visiblePacCount; i++) {
        var inputs: string[] = readline().split(' ');
        const pacId: number = parseInt(inputs[0]); // pac number (unique within a team)
        const mine: boolean = inputs[1] !== '0'; // true if this pac is yours
        var xpos : number  = parseInt(inputs[2]); // position in the grid
        var ypos : number  = parseInt(inputs[3]); // position in the grid
        const typeId: string = inputs[4]; // unused in wood leagues
        const speedTurnsLeft: number = parseInt(inputs[5]); // unused in wood leagues
        const abilityCooldown: number = parseInt(inputs[6]); // unused in wood leagues
        let cell:Cell = board[toBoardNumber(xpos,ypos)];
        cell.setPacmanId(pacId)
        
        if (mine == true){       
            if(myPacmans.has(pacId)){
                var pacman :Pacman = myPacmans.get(pacId)
                pacman.setCell(cell)
                pacman.setSpeedColdown(speedTurnsLeft+abilityCooldown)
                pacman.setSpeedTurnsLeft(speedTurnsLeft)
                pacman.setType(PacmanType[typeId])

            }else{
                var p :Pacman = new Pacman(pacId, cell)

                p.setType(PacmanType[typeId])
                myPacmans.set(pacId, p)
            }
        } else{
            var p :Pacman = new Pacman(pacId, cell)

            p.setType(PacmanType[typeId])
            evilPacmans.set(pacId, p)
        }
    }
    const visiblePelletCount: number = parseInt(readline()); // all pellets in sight
    for (let i = 0; i < visiblePelletCount; i++) {
        var inputs: string[] = readline().split(' ');
        const x: number = parseInt(inputs[0]);
        const y: number = parseInt(inputs[1]);
        const value: number = parseInt(inputs[2]); // amount of points this pellet is worth
        let cell:Cell = board[toBoardNumber(x,y)];
        if(cell.getX() != x || cell.getY() != y){
            console.error("x " + x + "y" + y)
            console.error(" found x " + cell.getX() + "y" + cell.getY())
        }
        
        cell.setPebbleScore(value)
        if(x == 15 && y == 3){
            console.error("pebble score " +cell.getPebbleScore())
            console.error("pebble score red "+ value)
        }

    }
    // Write an action using console.log()
    // To debug: console.error('Debug messages...');

    
    var output : String = ""
    for (let pacman of  myPacmans.values()){
        if (!pacman.isSpeedOnColdown()){
            if (output.length > 0 ){
                output = output.concat("|")
            }
            output = output.concat("SPEED " + pacman.getId())
            continue
        }
        
        var startCell : Cell = pacman.getCell()
        
        if (pacman.needNewStrategy()){
            console.error("I am standing still bad ")
            setOtherPacmanRoute(pacman, board)
            if (output.length > 0 ){
                output = output.concat("|")
            }
            output = output.concat("MOVE " + pacman.getId() +" " +pacman.getExploreX() + ' ' + pacman.getExploreY())
            continue
        }

        var cell : Cell = findPath(startCell.getX(), startCell.getY(), board, pacman, myPacmans, evilPacmans)
        if(cell != null){
            console.error("Cell found : " + cell.getX() + cell.getY())
            cell.setPebbleScore(0) //Eaten find
            if (output.length > 0 ){
                output = output.concat("|")
            }
            output = output.concat("MOVE " + pacman.getId() +" " +cell.getX() + ' ' + cell.getY())
        } 
        else {
            console.error("Did not find pebble")
            if (output.length > 0 ){
                output = output.concat("|")
            }
            if (!pacman.standOnExplore()){
               console.error("Found where I wanted to go updating")
               setOtherPacmanRoute(pacman, board)
            }

            output = output.concat("MOVE " + pacman.getId() +" " + pacman.getExploreX() + ' ' + pacman.getExploreY())
        }
        board.forEach(function(c :Cell) {
            c.setDiscovered(false)
        })
     
    }

    
    if (output != null){
          console.log(output);     // MOVE <pacId> <x> <y>
    } else{
        //got null bug!!
        console.error("FOUND NO PATH BAD!")
         console.log('MOVE 0 5 5')
    }  

}
